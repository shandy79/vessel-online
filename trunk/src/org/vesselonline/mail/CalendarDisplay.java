package org.vesselonline.mail;

import java.io.IOException;
import java.util.Calendar;
import java.util.Vector;
import javax.swing.JTable;
import com.google.api.client.util.DateTime;
import com.google.api.services.calendar.model.CalendarListEntry;
import com.google.api.services.calendar.model.Event;
import com.google.api.services.calendar.model.Events;

public class CalendarDisplay extends BriefingDisplay {
  /**
   * For Serializable interface, value generated by Eclipse.
   */
  private static final long serialVersionUID = -4413375209184284354L;

  private CalendarListEntry calendarListEntry;
  private Events events;

  private static final Vector<String> COLUMN_NAMES = new Vector<String>(3);
  static {
    COLUMN_NAMES.add("#");
    COLUMN_NAMES.add("Summary");
    COLUMN_NAMES.add("Date & Time");
  }

  public CalendarDisplay(int tabIndex, int delay, CalendarListEntry calendarListEntry) {
    super(tabIndex, calendarListEntry.getSummary(), delay, COLUMN_NAMES);
    this.calendarListEntry = calendarListEntry;
  }

  public Events getEvents() { return events; }
  public String getCalendarListEntryID() { return calendarListEntry.getId(); }

  @Override
  protected JTable createTable() {
    return new CalendarDialogTable(this);
  }

  @Override
  protected void refresh() throws DailyBriefingException {
    Vector<String> row;
    int eventCount = 0;

    Calendar now = Calendar.getInstance();
    // While "Z" indicates UTC time, the time zone used is the calendar default, so correct range is selected
    String currentDateTimeStr = new DateTime(now.getTime()).toStringRfc3339() + "Z";
    // Date range is 7 days from right now, events that are currently occurring are displayed
    now.add(Calendar.DATE, 7);
    String maxDateTimeStr = new DateTime(now.getTime()).toStringRfc3339() + "Z";

    try {
      events = DailyBriefingUtils.INSTANCE.getGoogleCalendarService().events().list(getCalendarListEntryID())
          .setTimeMin(currentDateTimeStr).setTimeMax(maxDateTimeStr).setSingleEvents(true).setOrderBy("startTime").execute();

      // Empty the current table data, then reload with retrieved tasks
      getTableModel().setRowCount(0);
      while (events.getItems() != null) {
        for (Event event : events.getItems()) {
          eventCount++;
          row = new Vector<String>(2);
          row.add(0, Integer.toString(eventCount));
          row.add(1, event.getSummary());
          row.add(2, DailyBriefingUtils.INSTANCE.eventDateTimeRangeToString(event));

          getTableModel().addRow(row);
        }
        String pageToken = events.getNextPageToken();
        if (pageToken != null && ! pageToken.isEmpty()) {
          events = DailyBriefingUtils.INSTANCE.getGoogleCalendarService().events().list(getCalendarListEntryID()).setPageToken(pageToken)
              .setTimeMin(currentDateTimeStr).setTimeMax(maxDateTimeStr).setSingleEvents(true).setOrderBy("startTime").execute();
        } else {
          break;
        }
      }

      // Update time and event count labels
      getTimeLabel().setText(DailyBriefingUtils.INSTANCE.getCurrentTime());
      getMessageLabel().setText(eventCount + " events");
    } catch (IOException ioe) {
      throw new DailyBriefingException(ioe);
    }
  }

  @Override
  protected void handleException(DailyBriefingException dbe) {
    getMessageLabel().setText(dbe.getCause().getMessage());
    dbe.printStackTrace();
  }
}
